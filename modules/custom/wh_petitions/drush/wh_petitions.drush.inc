<?php

function wh_petitions_drush_command() {
  $items = array();

  $items['petitions-generate'] = array(
    'callback' => 'wh_petitions_generate',
    'description' => "Generate random petitions for testing.",
    'arguments' => array(
      'number' => 'The number of petitions to generate.',
      'uid' => 'The user ID to create the petitions with.',
      'status' => 'The petition status to generate these petitions with.',
    ),
    'aliases' => array('petgen'),
  );

  $items['petitions-check-compliance-review-threshold'] = array(
    'callback' => 'wh_petitions_compliance_review_threshold_check_drush',
    'description' => "Check for petitions with enough signatures to pass the compliance review threshold.",
    'arguments' => array(
    ),
    'aliases' => array('petcrt'),
  );

  $items['petitions-signatures-report'] = array(
    'callback' => 'wh_petitions_signatures_report',
    'description' => 'Create a list of signatures for a specific petition.',
    'arguments' => array(
      'petition_id' => "The long string unique ID of the petition. Can be found in mongoDB",
      'name' => "Human readable name to be used in filename like this: signatures-report.petition_id.name.txt",
    ),
    'options' => array(
      'report_type' => "Define the appropriate report to run (e.g. email_csv).",
      'filepath' => "Set the file path that the report will be written to",
      'uids' => 'Path to list of uids waiting to be processed (generated by petitions-get-signatures-uids). Note: UIDs will be removed from this list as they get processed.',
    ),
    'aliases' => array('sig-report'),
  );

  $items['petitions-signatures-report-get-signatures-count'] = array(
    'callback' => 'wh_petitions_get_signatures_count',
    'description' => 'Returns a count of signatures in petition',
    'arguments' => array(
      'petition_id' => "The long string unique ID of the petition. Can be found in mongoDB",
    ),
    'options' => array(
      'filepath' => "Set the file path that the report will be written to",
      'name' => 'Name to use in file',
    ),
    'examples' => array(
      'drush sig-count 509a9ec76ce61c3449000005' => 'Get signature count for this petition',
      'drush sig-count 509a9ec76ce61c3449000005 --name=Louisiana --filepath=/home/bryanhirsch' => 'Write results to a file called /home/bryanhirsch/signatures-count.509a9ec76ce61c3449000005.Louisiana.txt',
    ),
    'aliases' => array('sig-count', 'pgsc'),
  );

  $items['petitions-signatures-report-get-signatures-uids'] = array(
    'callback' => 'wh_petitions_get_signatures_uids',
    'description' => 'Writes a list of signatures uids for a petition',
    'arguments' => array(
      'petition_id' => "The long string unique ID of the petition. Can be found in mongoDB",
    ),
    'options' => array(
      'filepath' => "Set the file path that the report will be written to",
      'name' => 'Name to use in file',
    ),
    'examples' => array(
      'drush sig-uids 509a9ec76ce61c3449000005' => 'Get signature uids for this petition',
      'drush sig-uids 509a9ec76ce61c3449000005 --name=Louisiana --filepath=/home/bryanhirsch' => 'Write results to a file called /home/bryanhirsch/signatures-uids.509a9ec76ce61c3449000005.Louisiana.txt',
    ),
    'aliases' => array('sig-uids', 'pgsu'),
  );

  $items['petitions-signatures-report-get-signatures-with-ips'] = array(
    'callback' => 'wh_petitions_get_signatures_uids_with_ips',
    'description' => 'Writes a list of signatures uids and IPs for a petition',
    'arguments' => array(
      'petition_id' => "The long string unique ID of the petition. Can be found in mongoDB",
    ),
    'options' => array(
      'filepath' => "Set the file path that the report will be written to",
      'name' => 'Name to use for file',
    ),
    'examples' => array(
      'drush sig-uids 509a9ec76ce61c3449000005' => 'Get signature uids for this petition',
      'drush sig-uids 509a9ec76ce61c3449000005 --name=Louisiana --filepath=/home/bryanhirsch' => 'Write results to a file called /home/bryanhirsch/signatures-uids.509a9ec76ce61c3449000005.Louisiana.txt',
    ),
  );
  
  return $items;
}

function wh_petitions_generate($number, $uid = NULL, $status = NULL) {
  module_load_include('inc', 'wh_petitions', 'wh_petitions.generate');
  create_petitions($number, $uid, $status);
}

function wh_petitions_compliance_review_threshold_check_drush() {
  $email = variable_get('wh_petitions_compliance_reviewer_emails', FALSE);
  $threshold = (int)variable_get('wh_petitions_compliance_review_threshold', FALSE);

  if ($email && $threshold) {
    wh_petitions_compliance_review_threshold_check($threshold, $email);
  }  
}

/**
 * Write a file with a list of petition signatures for a
 * requested petition.
 *
 * @param string $petition_id
 *
 * @return
 */
function wh_petitions_signatures_report($petition_id, $name) {
  // Get path to file where report should be written.
  if(!$filepath = drush_get_option('filepath')) {
    drush_print('please specify --filepath option');
    return;
  }
  else {
    $filename = sprintf('%s/signatures-report.%s.%s.txt', $filepath, $petition_id, $name);
    if (file_exists($filename)) {
      // If this file already exists, stop and tell user to delete it. Otherwise the same data
      // could get appended to this file twice.
      drush_print("This file already exists. Remove it before re-creating this report.\n$filename");
      return;
    }
  }

  if (!$uids_file = drush_get_option('uids')) {
    // $uids = _wh_petitions_get_signatures_uids($petition_id);
    drush_print('Please designate a file where uids are queued for processing. Use petitions-signatures-report-get-signatures-uids to generate this file.');
  }

  // Process uids for report in batches.
  while ($uids = _wh_petitions_get_uids_batch($uids_file)) {
    $rows = _wh_petitions_signatures_report_rows($uids);
    file_put_contents($filename, implode(PHP_EOL, $rows), FILE_APPEND);
  }
  // All $uids have been procesed. We're all done.
  drush_print("All uids have been processed and stored here:"
    . "\n$filename\n\n"
    . "Double check results count like this:\n\t cat $filename | wc -l");

}

/**
 * @return array
 *  Rows to be appended to a petitions signatures report.
 */
function _wh_petitions_signatures_report_rows($uids) {

  // DEBUGGING
  drush_print(count($uids) . " uids passed to query.");
  drush_print(count(array_unique($uids)) . " unique uids passed to query.");

  //Set up the report type.
  if(!$report_type = drush_get_option('report_type')) {
    $report_type = '';
  }

  $mysql_query = db_select('users', 'u');
  $mysql_query->fields('u', array('uid', 'mail'));
  // If we're only generating an email_csv, skip joins. Not necessary.
  if ($report_type == 'email_csv') {
    $mysql_query->join('field_data_field_first_name', 'fn', 'u.uid = fn.entity_id');
    $mysql_query->join('field_data_field_last_name', 'ln', 'u.uid = ln.entity_id');
    $mysql_query->join('field_data_field_city', 'fc', 'u.uid = fc.entity_id');
    $mysql_query->join('field_data_field_state', 'fs', 'u.uid = fs.entity_id');
    $mysql_query->join('field_data_field_zip', 'fz', 'u.uid = fz.entity_id');
    $mysql_query->fields('fn', array('field_first_name_value'));
    $mysql_query->fields('ln', array('field_last_name_value'));
    $mysql_query->fields('fc', array('field_city_value'));
    $mysql_query->fields('fs', array('field_state_value'));
    $mysql_query->fields('fz', array('field_zip_value'));
  }
  $mysql_query->condition('u.uid', $uids, 'IN');
  /*
    $result = $mysql_query->execute();
  // */
// DEBUGGING
  $result = db_query("SELECT uid, mail FROM {users} WHERE uid IN (:uids) ", array(':uids' => $uids));

  $rows = array();

  while ($record = $result->fetchAssoc()) {

    switch($report_type) {
      case 'email_csv':
        $rows[] = $record['mail'];
        break;

      default:
        $row = array(
          'uid' => $record['uid'],
          'mail' => $record['mail'],
          'firstname' => _wh_petitions_csv_sanitize($record['field_first_name_value']),
          'lastname' => _wh_petitions_csv_sanitize($record['field_last_name_value']),
          'city' => _wh_petitions_csv_sanitize($record['field_city_value']),
          'state' => _wh_petitions_csv_sanitize($record['field_state_value']),
          'zip' => $record['field_zip_value'],
          'signature_timestamp' => $timestamps[$record['uid']]
        );
        $rows[] = $row;
        break;
    }
  }

// DEBUGGING
  drush_print(count($rows) . " returned");
  return $rows;
}

/**
 * @param string $petition_id
 * @param string $name
 *
 * @return integer
 *  Signature count.
 */
function wh_petitions_get_signatures_count($petition_id) {
  $uids = _wh_petitions_get_signatures_uids($petition_id);
  $count = count($uids);
  drush_print("$count signatures");

  $filepath = drush_get_option('filepath');
  $name = drush_get_option('name');
  if($filepath && $name) {
    $file_name = sprintf('%s/signature-count.%s.%s.txt', $filepath, $petition_id, $name);
    drush_print('Writing results to file: ' . $file_name);
    file_put_contents($file_name, "$count signatures");
  }
}

/**
 * Get list of uids of for a petition's signature.
 * Write results to file.
 *
 * @param string $petition_id
 *
 * TODO decide what exactly to return in what format.
 * @return array
 *   $results[] = array('timestamp' => timestamp, 'uid' => uid)
 */
function wh_petitions_get_signatures_uids($petition_id) {
  $filepath = drush_get_option('filepath');
  $name = drush_get_option('name');
  if (!$filepath || !$name) {
    drush_print('Please use --name and --filepath options');
    return;
  }

  $uids = _wh_petitions_get_signatures_uids($petition_id);

  $id_list = '';
  foreach ($uids as $uid => $values) {
    $id_list .= $uid . ',';
  }

  $file_name = sprintf('%s/signatures-uids.%s.%s.txt', $filepath, $petition_id, $name);
  drush_print('Writing results to file: ' . $file_name);
  file_put_contents($file_name, $id_list);
}

/**
 * Get list of uids of for a petition's signature.
 * Write results to file.
 *
 * @param string $petition_id
 *
 * @return array
 *   $results[] = array('timestamp' => timestamp, 'uid' => uid)
 */
function _wh_petitions_get_signatures_uids($petition_id) {
  $collection = mongodb_collection('petition_signatures');

  $query = array('petition_id' => $petition_id);
  $fields = array('uid', 'timestamp', 'ip_address', 'user');

  $mongo_signatures = $collection->find($query, $fields);

  $id_list = array();
  foreach ($mongo_signatures as $signature) {
    $uid = $signature['uid'];
    $id_list[$uid] = array(
      'uid' => $uid,
      'username' => $signature['user']['username'],
      'timestamp' => $signature['timestamp'],
      'ip_address' => $signature['ip_address'],
    );
  }
  ksort($id_list);

  return $id_list;
}

function _wh_petitions_csv_sanitize($data) {
  $data = check_plain($data);
  $data = str_replace(',', '&#44;', $data);
  return $data;
}

/**
 * Return a batch of uids to be processed. Remove these from the
 * file used to queue and process uids.
 *
 * @param string $uids_file
 *
 * @return array $uids
 */
function _wh_petitions_get_uids_batch($uids_file, $batch_size = 200) {
  // TODO Make batch size configurable.
  $contents = file_get_contents($uids_file);
  $uids = explode(",", $contents);
  drush_print("processing uids from $uids_file");
  drush_print("processing $batch_size uids now");

  // Shift a batch of uids off $uids to be processed.
  $batch = array();
  for($i = 0; $i < $batch_size; $i++) {
    $count = count($uids);
    if ($count == 0) {
      break;
    }
    $batch[] = array_shift($uids);
  }

  if ($count > 0) {
    // Rewrite $uids_file with remainder to be processed later.
    drush_print("uids remaining to be processed: $count");
    $contents = implode(',', $uids);
    $write = file_put_contents($uids_file, $contents);

    // Return batch of uids to be processed.
    return $batch;
  }
  else {
    return FALSE;
  }

}

/**
 * @param title
 *
 * This prints info (petition_id and nice_url) about the requested petition.
 */
function wh_petitions_get_id($title) {
  // Use the petitions "collection" (this is like a mongo table).
  $collection = mongodb_collection('petitions');

  $query = array('title' => $title);
  $fields = array('_id', 'title', 'nice_url');
  $petitions = $collection->find($query, $fields);

  foreach ($petitions as $petition) {
    foreach($petition['_id'] as $id) {
      $petition_id = $id;
    }
    drush_print("Here's what I found in mongo:\n");
    drush_print("title: " . $petition['title']);
    drush_print("nice_url: " . $petition['nice_url']);
    drush_print("petition_id: " . $petition_id . "\n");
  }
}

/**
 * Get list of uids and ips of for a petition's signatures.
 * Write results to file.
 *
 * @param string $petition_id
 */
function wh_petitions_get_signatures_uids_with_ips($petition_id) {
  $filepath = drush_get_option('filepath');
  $name = drush_get_option('name');
  if (!$filepath || !$name) {
    drush_print('Please use --name and --filepath options');
    return;
  }

  $uids = _wh_petitions_get_signatures_uids($petition_id);

  $id_list = "uid, username, ip_address, timestamp\n";
  foreach ($uids as $uid => $values) {
    $id_list .= sprintf("%s, %s, %s, %s\n",
      $values['uid'],
      $values['username'],
      $values['ip_address'],
      $values['timestamp']);
  }

  $file_name = sprintf('%s/signatures-uids-with-ips.%s.%s.txt', $filepath, $petition_id, $name);
  drush_print('Writing results to file: ' . $file_name);
  file_put_contents($file_name, $id_list);

}
