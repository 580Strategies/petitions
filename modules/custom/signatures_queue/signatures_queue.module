<?php

/**
 * @file
 * The signature queue system.
 *
 * Provides SignaturesQueue class, configuration for signatures queues, and a
 * queue monitoring dashboard.
 */

/**
 * The default workflow batch size.
 */
define('SIGNATURES_QUEUE_BATCH_SIZE_DEFAULT', 10);

/**
 * The default value for the signatures_queue_log_events variable.
 */
define('SIGNATURES_QUEUE_LOG_EVENTS_DEFAULT', TRUE);

/**
 * The default value for the server-name event logging value.
 */
define('SIGNATURES_QUEUE_SERVER_NAME_DEFAULT', 'default');

/**
 * The default value for the worker-name event logging value.
 */
define('SIGNATURES_QUEUE_WORKER_NAME_DEFAULT', 'default');

/**
 * Implements hook_menu().
 */
function signatures_queue_menu() {
  $items = array();

  $items['admin/config/system/signatures-queue'] = array(
    'title' => 'Petition Signatures Queue',
    'description' => 'Overview of petition signatures queue system',
    'page callback' => 'signatures_queue_overview',
    'access arguments' => array('monitor queues'),
    'file' => 'signatures_queue.pages.inc',
  );
  $items['admin/config/system/signatures-queue/monitor'] = array(
    'title' => 'Monitor',
    'description' => 'Monitor signature queues',
    'page callback' => 'signatures_queue_monitor_page',
    'access arguments' => array('monitor queues'),
    'type' => MENU_LOCAL_TASK,
    'weight' => 1,
    'file' => 'signatures_queue.pages.inc',
  );
  $items['admin/config/system/signatures-queue/settings'] = array(
    'title' => 'Settings',
    'description' => 'Configure signature queues',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('signatures_queue_configure'),
    'access arguments' => array('administer queues'),
    'type' => MENU_LOCAL_TASK,
    'weight' => 3,
    'file' => 'signatures_queue.admin.inc',
  );
  $items['thank-you'] = array(
    'title' => 'Thank You',
    'page callback' => '_signatures_queue_validation_page_callback',
    'access arguments' => array('access content'),
    'file' => 'signatures_queue.pages.inc',
  );
  $items['thank-you/%'] = array(
    'title' => 'Thank You',
    'page callback' => '_signatures_queue_validated_page_callback',
    'page arguments' => array(1),
    'access arguments' => array('access content'),
    'file' => 'signatures_queue.pages.inc',
  );
  $items['validation-error'] = array(
    'title' => 'Validation Error',
    'page callback' => '_signatures_queue_validation_error_page_callback',
    'access arguments' => array('access content'),
    'file' => 'signatures_queue.pages.inc',
  );
  $items['petition-error'] = array(
    'title' => 'Petition Not Found',
    'page callback' => '_signatures_queue_petition_error_page_callback',
    'access arguments' => array('access content'),
    'file' => 'signatures_queue.pages.inc',
  );

  return $items;
}

/**
 * Implements hook_permission().
 */
function signatures_queue_permission() {
  return array(
    'administer queues' => array(
      'title' => t('Administer signatures queue'),
    ),
    'monitor queues' => array(
      'title' => t('Monitor signatures queue'),
    ),
  );
}

/**
 * Implements hook_mail().
 */
function signatures_queue_mail($key, &$message, $params) {
  if ($key == 'initiate_signature_validation') {
    module_load_include('inc', 'signatures_queue');
    $language = $message['language'];
    $message['subject'] = _signatures_queue_validation_mail_text($key . '_subject', $language, $params);
    $message['body'][] = _signatures_queue_validation_mail_text($key . '_body', $language, $params);
  }
}

/**
 * Token callback to add unsafe tokens for signature validation mails.
 *
 * This function is used by the token_replace() call at the end of
 * _signatures_queue_validation_mail_text() to set up some additional tokens
 * that can be used in email messages generated by
 * _signatures_queue_send_validation_emails().
 *
 * @param $replacements
 *   An associative array variable containing mappings from token names to
 *   values (for use with strtr()).
 * @param $data
 *   An associative array of token replacement values.
 * @param $options
 *   Unused parameter required by the token_replace() function.
 */
function signatures_queue_validation_email_tokens(&$replacements, $data, $options) {
  if (isset($data['signature info'])) {
    global $base_url;
    $website_url = variable_get('petitions_data_petitions_website_url', $base_url);

    // Sanitize petition data.
    foreach($data['signature info'] as $key => $info) {
      $data['signature info'][$key] = check_plain($info);
    }

    // Tokens for all values in the signature_info array.
    // Creating $petition_id because it will be used several times.
    $petition_id = $data['signature info']['petition_id'];
    $replacements['[signature:petition-id]'] = $petition_id;
    $replacements['[signature:first-name]'] = $data['signature info']['first_name'];
    $replacements['[signature:last-name]'] = $data['signature info']['last_name'];
    $replacements['[signature:zip]'] = $data['signature info']['zip'];
    $replacements['[signature:email]'] = $data['signature info']['email'];
    $replacements['[signature:signup]'] = $data['signature info']['signup'];
    $replacements['[signature:timestamp-submitted]'] = $data['signature info']['timestamp_submitted'];
    // Creating $key because it will be used several times.
    $key = $data['signature info']['secret_validation_key'];
    $replacements['[signature:secret-validation-key]'] = $key;
    // Creating $md5 because it will be used several times.
    $md5 = $data['signature info']['md5_encryption_key'];
    $replacements['[signature:signature-md5-encryption-key]'] = $md5;
    // @todo Retrieve the application/organization name associated with
    // $data['signature_info']['signature_source_api_key'] for use in the email.
    $replacements['[signature:signature-source-api-key]'] = $data['signature info']['signature_source_api_key'];
    // Tokens for additional values.
    $replacements['[signature:validation-url]'] = $base_url . "/thank-you?k={$key}&m={$md5}&p={$petition_id}";
    // Load the petition via the API retrieve method.
    $petition = PetitionsRetrieveRawFactory::create()->setBaseURL($website_url)->load($petition_id);
    if (!empty($petition['results'])) {
      // Tokens for values associated to the petition.
      $replacements['[petition:title]'] = $petition['results'][0]['title'];
      $replacements['[petition:url]'] = $petition['results'][0]['url'];
    }
  }
}

/**
 * Implements hook_shunt().
 */
function signatures_queue_shunt() {
  // Automatically declare a shunt for each workflow.
  $shunts = array();
  $workflows = signatures_queue_get_workflow_names();
  foreach ($workflows as $workflow) {
    $name = "shunt_signatures_queue_{$workflow}";
    $description = t('A shunt for the "@workflow" workflow.', array(
      '@workflow' => str_replace('_', ' ', ucfirst($workflow)),
    ));
    $shunts[$name] = $description;
  }
  return $shunts;
}

/**
 * Gets an array of queue names.
 *
 * Note: Real queues are named something_queue. The tables listed here that
 * don't end in the suffix "_queue" aren't actually queues. Conceptually
 * they're part of the "signatures queue" in the sense that these are holding
 * bins where signatures go before they're done being processed and counted.
 * But they're not DrupalQueue queues.
 *
 * @return array
 *   Array of signature queues and descriptions keyed by queue name.
 */
function signatures_queue_get_queue_names() {
  return array(
    'signatures_submitted_queue' => t('Queue submissions received via API POST requests or form submissions by unauthenticated users.'),
    'signatures_pending_validation_queue' => t('Retrieve petitions from signatures_submitted_queue, send a validation email, then move the pending signature here.'),
    'signatures_validated_queue' => t('When a user clicks a validation link received via email, store the secret validation key here.'),
    'signatures_validated' => t('Move records from signatures_validated_queue to here for processing.'),
    'signatures_pending_validation' => t('Move records from signatures_pending_validation_queue to here for processing.'),
    'signatures_orphans' => t('When processing validated signatures, records in signatures_validated that do not have matching records in signatures_pending_validation are orphans.'),
  );
}

/**
 * Gets a list of workflow names.
 *
 * @return array
 *   An indexed array of workflow names.
 */
function signatures_queue_get_workflow_names() {
  return array(
    'receive_new_signatures',
    'initiate_signature_validation',
    'receive_signature_validation',
    'preprocess_signatures',
    'process_signatures',
    'archive_signatures',
  );
}

/**
 * Invokes a given workflow.
 *
 * This function is normally invoked via Drush, i.e.
 * `drush signatures-queue-invoke-workflow`.
 *
 * @param string $workflow
 *   The name of the workflow to invoke, as defined in
 *   signatures_queue_get_workflow_names().
 * @param string $server_name
 *   (optional) The name of the server processing the workflow. Defaults to
 *   SIGNATURES_QUEUE_SERVER_NAME_DEFAULT.
 * @param string $worker_name
 *   (optional) An arbitrary identifier for the invoking process (e.g., cron
 *   job). Defaults to SIGNATURES_QUEUE_WORKER_NAME_DEFAULT.
 * @param array $options
 *   (optional) An array of arbitrary options data as required by particular
 *   workflows. Defaults to an empty array.
 *
 * @return bool
 *   Returns TRUE if the workflow was successfully processed or FALSE if not.
 */
function signatures_queue_invoke_workflow($workflow, $server_name = SIGNATURES_QUEUE_SERVER_NAME_DEFAULT, $worker_name = SIGNATURES_QUEUE_WORKER_NAME_DEFAULT, array $options = array()) {
  // Fail if given workflow is invalid.
  if (!in_array($workflow, signatures_queue_get_workflow_names())) {
    return FALSE;
  }

  // Detect a shunt trip.
  $shunt_name = "shunt_signatures_queue_{$workflow}";
  if (shunt_is_enabled($shunt_name)) {
    // Return TRUE because the workflow didn't fail--it was deliberately
    // deferred, which isn't properly an error condition.
    return TRUE;
  }

  $logging_enabled = variable_get('signatures_queue_log_events', SIGNATURES_QUEUE_LOG_EVENTS_DEFAULT);

  // Invoke the workflow.
  module_load_include('inc', 'signatures_queue', "includes/{$workflow}");
  $function_name = "signatures_queue_{$workflow}";
  $success = FALSE;
  if (function_exists($function_name)) {
    module_load_include('inc', 'signatures_queue');

    // Log job start.
    $job_id = _signatures_queue_create_job_id($workflow, $server_name, $worker_name);
    _signatures_queue_log_event($job_id, $workflow, $server_name, $worker_name, 'started');

    // Dispatch the worker.
    $success = call_user_func($function_name, $job_id, $server_name, $worker_name, $options);

    // Log job completion.
    _signatures_queue_log_event($job_id, $workflow, $server_name, $worker_name, 'completed');
  }
  return $success;
}

/**
 * Set active database according to settings.php configuration.
 *
 * Don't forget to call db_set_active() to set back to default after using this.
 */
function signatures_queue_set_db($conf_name = 'signatures_processing') {
  global $databases;
  if (!empty($databases[$conf_name])) {
    // Set database so that we create the tables there.
    db_set_active($conf_name);
  }
}

/**
 * Get batch size.
 *
 * Get admin-defined number of pending and validated records to be processed at
 *   a time (which can be adjusted during heavy load).
 */
function signatures_queue_get_queue_batch_size($workflow) {
  // Fail if given workflow is invalid.
  if (!in_array($workflow, signatures_queue_get_workflow_names())) {
    return FALSE;
  }

  // Get the size from the configured variable.
  $batch_size = variable_get("signatures_queue_${workflow}_batch_size", SIGNATURES_QUEUE_BATCH_SIZE_DEFAULT);

  // If there are other load handling adjustments, they can be added here.
  $load = sys_getloadavg();
  // 8 is chosen for a 6 to 8 core CPU server. Load is typically < 1.
  if ($load[0] > 8) {
    // Scale down the batch with higher load.
    // Example: if $batch_size is 200 and load is 10, $batch_size will be 20.
    $batch_size = $batch_size / $load[0];
    // Log the $batch_size scaling? watchdog(...);
  }

  return (int) $batch_size;
}
